<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spline Editor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .controls {
            margin-bottom: 20px;
        }
        .control-point {
            margin-bottom: 10px;
        }
        canvas {
            border: 1px solid #ccc;
            display: block;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Spline Editor</h1>

    <div class="controls" id="controls">
        <!-- Controls for each control point -->
    </div>

    <canvas id="splineCanvas" width="1400" height="400"></canvas>

    <script>
        function interpolate(t, degree, points, knots, weights, result) {

        var i,j,s,l;              // function-scoped iteration variables
        var n = points.length;    // points count
        var d = points[0].length; // point dimensionality

        if(degree < 1) throw new Error('degree must be at least 1 (linear)');
        if(degree > (n-1)) throw new Error('degree must be less than or equal to point count - 1');

        if(!weights) {
        // build weight vector of length [n]
        weights = [];
        for(i=0; i<n; i++) {
            weights[i] = 1;
        }
        }

        if(!knots) {
        // build knot vector of length [n + degree + 1]
        var knots = [];
        for(i=0; i<n+degree+1; i++) {
            knots[i] = i;
        }
        } else {
        if(knots.length !== n+degree+1) throw new Error('bad knot vector length');
        }

        var domain = [
        degree,
        knots.length-1 - degree
        ];

        // remap t to the domain where the spline is defined
        var low  = knots[domain[0]];
        var high = knots[domain[1]];
        t = t * (high - low) + low;

        if(t < low || t > high) throw new Error('out of bounds');

        // find s (the spline segment) for the [t] value provided
        for(s=domain[0]; s<domain[1]; s++) {
        if(t >= knots[s] && t <= knots[s+1]) {
            break;
        }
        }

        // convert points to homogeneous coordinates
        var v = [];
        for(i=0; i<n; i++) {
        v[i] = [];
        for(j=0; j<d; j++) {
            v[i][j] = points[i][j] * weights[i];
        }
        v[i][d] = weights[i];
        }

        // l (level) goes from 1 to the curve degree + 1
        var alpha;
        for(l=1; l<=degree+1; l++) {
        // build level l of the pyramid
        for(i=s; i>s-degree-1+l; i--) {
            alpha = (t - knots[i]) / (knots[i+degree+1-l] - knots[i]);

            // interpolate each component
            for(j=0; j<d+1; j++) {
            v[i][j] = (1 - alpha) * v[i-1][j] + alpha * v[i][j];
            }
        }
        }

        // convert back to cartesian and return
        var result = result || [];
        for(i=0; i<d; i++) {
        result[i] = v[s][i] / v[s][d];
        }

        return result;
        }
        const knots = [0,0,0,0,1,1,1,1];
        function computeKnot(controlPoints,m){
            N=controlPoints.length;

            const coreArray = Array.from({ length: N - m + 1 }, (_, i) => i);

        // Step 2: Append m zeros to the beginning
            const startPadding = Array(m).fill(0);

        // Step 3: Append m [N-m]s to the end
            const endPadding = Array(m).fill(N - m);

        // Combine the arrays
            return [...startPadding, ...coreArray, ...endPadding];  
        }
        const controlPoints = [
            { x: 100, y: 200, enabled: true },
            { x: 200, y: 200, enabled: true },
            { x: 300, y: 200, enabled: true },
            { x: 400, y: 200, enabled: true },
            { x: 500, y: 200, enabled: true },
            { x: 600, y: 200, enabled: true },
            { x: 700, y: 200, enabled: true },
            { x: 800, y: 200, enabled: true },
            { x: 900, y: 200, enabled: true },
            { x: 1000, y: 200, enabled: true }
            
        ];
        const canvas = document.getElementById("splineCanvas");
        const ctx = canvas.getContext("2d");
        let degree=3;
        function drawSpline(points) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const controlPoints = points.filter(point => point.enabled);
            if (controlPoints.length==2) {
                degree=1;
            } else if (controlPoints.length==3) {
                degree=2;
            } else {
                degree =3;
            }
            console.log(degree);
            const knots=computeKnot(controlPoints,degree);
            // Draw control points
            ctx.fillStyle = 'red';
            controlPoints.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw the B-spline curve
            ctx.beginPath();
            ctx.moveTo(controlPoints[0].x, controlPoints[0].y);

            let result = [];
            for (let t = 0; t <= 1.00; t += 0.001) {
                const point = interpolate(t, degree, controlPoints.map(p => [p.x, p.y]), knots);
                ctx.lineTo(point[0], point[1]);
            }

            ctx.strokeStyle = 'black';
            ctx.stroke();


        }

        const controlsDiv = document.getElementById("controls");



        function updateControlPoint(index, y) {
            controlPoints[index].y = y;
            drawSpline(controlPoints);
        }

        function toggleControlPoint(index, enabled) {
            controlPoints[index].enabled = enabled;
            drawSpline(controlPoints);
        }

        function setupControls() {
            controlPoints.forEach((point, index) => {
                const controlDiv = document.createElement("div");
                controlDiv.className = "control-point";

                const label = document.createElement("label");
                label.textContent = `Point ${index + 1}: `;
                label.htmlFor = `input${index}`;

                const input = document.createElement("input");
                input.type = "number";
                input.value = point.y;
                input.id = `input${index}`;
                input.addEventListener("input", (e) => {
                    const newValue = parseInt(e.target.value, 10);
                    point.y = newValue;
                    updateControlPoint(index, newValue);
                });

                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.checked = point.enabled;
                checkbox.id = `checkbox${index}`;
                checkbox.addEventListener("change", (e) => {
                    toggleControlPoint(index, e.target.checked);
                });

                const checkboxLabel = document.createElement("label");
                checkboxLabel.textContent = " Enable";
                checkboxLabel.htmlFor = `checkbox${index}`;

                controlDiv.appendChild(label);
                controlDiv.appendChild(input);
                controlDiv.appendChild(checkbox);
                controlDiv.appendChild(checkboxLabel);

                controlsDiv.appendChild(controlDiv);
            });
        }

        function setupDragging() {
            let draggingPoint = null;

            canvas.addEventListener("mousedown", (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                draggingPoint = controlPoints.find(
                    point => point.enabled &&
                        Math.hypot(point.x - mouseX, point.y - mouseY) < 10
                );
            });

            canvas.addEventListener("mousemove", (e) => {
                if (draggingPoint) {
                    const rect = canvas.getBoundingClientRect();
                    const mouseY = e.clientY - rect.top;

                    draggingPoint.y = mouseY;
                    document.getElementById(`input${controlPoints.indexOf(draggingPoint)}`).value = mouseY;
                    drawSpline(controlPoints);
                }
            });

            canvas.addEventListener("mouseup", () => {
                draggingPoint = null;
            });
        }

        setupControls();
        setupDragging();
        drawSpline(controlPoints);
    </script>
</body>
</html>