<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spline with Sliders</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .slider-container {
            margin-bottom: 20px;
        }
        canvas {
            border: 1px solid #ccc;
            display: block;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Spline Control</h1>

    <div class="slider-container" id="sliders">
        <!-- Sliders will be dynamically added here -->
    </div>

    <canvas id="splineCanvas" width="1200" height="400"></canvas>

    <script>

        function interpolate(t, degree, points, knots, weights, result) {

        var i,j,s,l;              // function-scoped iteration variables
        var n = points.length;    // points count
        var d = points[0].length; // point dimensionality

        if(degree < 1) throw new Error('degree must be at least 1 (linear)');
        if(degree > (n-1)) throw new Error('degree must be less than or equal to point count - 1');

        if(!weights) {
        // build weight vector of length [n]
        weights = [];
        for(i=0; i<n; i++) {
            weights[i] = 1;
        }
        }

        if(!knots) {
        // build knot vector of length [n + degree + 1]
        var knots = [];
        for(i=0; i<n+degree+1; i++) {
            knots[i] = i;
        }
        } else {
        if(knots.length !== n+degree+1) throw new Error('bad knot vector length');
        }

        var domain = [
        degree,
        knots.length-1 - degree
        ];

        // remap t to the domain where the spline is defined
        var low  = knots[domain[0]];
        var high = knots[domain[1]];
        t = t * (high - low) + low;

        if(t < low || t > high) throw new Error('out of bounds');

        // find s (the spline segment) for the [t] value provided
        for(s=domain[0]; s<domain[1]; s++) {
        if(t >= knots[s] && t <= knots[s+1]) {
            break;
        }
        }

        // convert points to homogeneous coordinates
        var v = [];
        for(i=0; i<n; i++) {
        v[i] = [];
        for(j=0; j<d; j++) {
            v[i][j] = points[i][j] * weights[i];
        }
        v[i][d] = weights[i];
        }

        // l (level) goes from 1 to the curve degree + 1
        var alpha;
        for(l=1; l<=degree+1; l++) {
        // build level l of the pyramid
        for(i=s; i>s-degree-1+l; i--) {
            alpha = (t - knots[i]) / (knots[i+degree+1-l] - knots[i]);

            // interpolate each component
            for(j=0; j<d+1; j++) {
            v[i][j] = (1 - alpha) * v[i-1][j] + alpha * v[i][j];
            }
        }
        }

        // convert back to cartesian and return
        var result = result || [];
        for(i=0; i<d; i++) {
        result[i] = v[s][i] / v[s][d];
        }

        return result;
        }
        const knots = [0,0,0,0,1,1,1,1];
        function computeKnot(controlPoints,m){
            N=controlPoints.length;

            const coreArray = Array.from({ length: N - m + 1 }, (_, i) => i);

    // Step 2: Append m zeros to the beginning
            const startPadding = Array(m).fill(0);

    // Step 3: Append m [N-m]s to the end
            const endPadding = Array(m).fill(N - m);

    // Combine the arrays
            return [...startPadding, ...coreArray, ...endPadding];  
        }
        const controlPoints = [
            { x: 100, y: 200, enabled: true },
            { x: 200, y: 200, enabled: true },
            { x: 300, y: 200, enabled: true },
            { x: 400, y: 200, enabled: true },
            { x: 500, y: 200, enabled: true },
            { x: 600, y: 200, enabled: true },
            { x: 700, y: 200, enabled: true },
            { x: 800, y: 200, enabled: true },
            { x: 900, y: 200, enabled: true },
            { x: 1000, y: 200, enabled: true }
            
        ];
        console.log(controlPoints.length)
        const canvas = document.getElementById("splineCanvas");
        const ctx = canvas.getContext("2d");
        let degree=3;
        function drawSpline(points) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const controlPoints = points.filter(point => point.enabled);
            if (controlPoints.length==2) {
                degree=1;
            } else if (controlPoints.length==3) {
                degree=2;
            } else {
                degree =3;
            }
            console.log(degree);
            const knots=computeKnot(controlPoints,degree);
            // Draw control points
            ctx.fillStyle = 'red';
            controlPoints.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw the B-spline curve
            ctx.beginPath();
            ctx.moveTo(controlPoints[0].x, controlPoints[0].y);

            let result = [];
            for (let t = 0; t <= 1.00; t += 0.001) {
                const point = interpolate(t, degree, controlPoints.map(p => [p.x, p.y]), knots);
                ctx.lineTo(point[0], point[1]);
            }

            ctx.strokeStyle = 'black';
            ctx.stroke();


        }

        function updateControlPoint(index, y) {
            controlPoints[index].y = y;
            drawSpline(controlPoints);
        }

        function toggleControlPoint(index, enabled) {
            controlPoints[index].enabled = enabled;
            drawSpline(controlPoints);
        }

        // Create sliders dynamically
        const slidersDiv = document.getElementById("sliders");

        controlPoints.forEach((point, index) => {
            const sliderContainer = document.createElement("div");
            sliderContainer.className = "slider-container";

            const label = document.createElement("label");
            label.textContent = `Control Point ${index + 1} (y: ${point.y}): `;
            label.htmlFor = `slider${index}`;

            const slider = document.createElement("input");
            slider.type = "range";
            slider.min = "0";
            slider.max = "400";
            slider.value = point.y;
            slider.id = `slider${index}`;
            slider.addEventListener("input", (e) => {
                const newValue = parseInt(e.target.value, 10);
                label.textContent = `Control Point ${index + 1} (y: ${newValue}): `;
                updateControlPoint(index, newValue);
            });

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.checked = point.enabled;
            checkbox.id = `checkbox${index}`;
            checkbox.addEventListener("change", (e) => {
                toggleControlPoint(index, e.target.checked);
            });

            const checkboxLabel = document.createElement("label");
            checkboxLabel.textContent = " Enable";
            checkboxLabel.htmlFor = `checkbox${index}`;

            sliderContainer.appendChild(label);
            sliderContainer.appendChild(slider);
            sliderContainer.appendChild(checkbox);
            sliderContainer.appendChild(checkboxLabel);
            slidersDiv.appendChild(sliderContainer);
        });

        // Initial draw
        drawSpline(controlPoints);
    </script>
</body>
</html>
